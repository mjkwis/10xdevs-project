# API Endpoint Implementation Plan: GET /api/statistics/overview

## 1. Przegląd

**Endpoint:** `GET /api/statistics/overview`  
**Cel:** Ogólne statystyki użytkownika (dashboard overview)

## 2. Request

```
GET /api/statistics/overview
Authorization: Bearer {access_token}
```

## 3. Response (200 OK)

```json
{
  "statistics": {
    "total_flashcards": 150,
    "active_flashcards": 120,
    "pending_review_flashcards": 15,
    "rejected_flashcards": 15,
    "manual_flashcards": 50,
    "ai_generated_flashcards": 100,
    "ai_acceptance_rate": 0.87,
    "flashcards_due_today": 25,
    "total_generation_requests": 10,
    "total_reviews_completed": 500
  }
}
```

## 4. Implementation

### Service

```typescript
async getOverview(userId: string): Promise<StatisticsOverview> {
  // Query all counts in parallel
  const [
    totalFlashcards,
    activeFlashcards,
    pendingReviewFlashcards,
    rejectedFlashcards,
    manualFlashcards,
    aiGeneratedFlashcards,
    aiApproved,
    flashcardsDueToday,
    totalGenerationRequests
  ] = await Promise.all([
    this.countFlashcards(userId),
    this.countFlashcards(userId, { status: 'active' }),
    this.countFlashcards(userId, { status: 'pending_review' }),
    this.countFlashcards(userId, { status: 'rejected' }),
    this.countFlashcards(userId, { source: 'manual' }),
    this.countFlashcards(userId, { source: 'ai_generated' }),
    this.countFlashcards(userId, { source: 'ai_generated', status: 'active' }),
    this.countDueFlashcards(userId),
    this.countGenerationRequests(userId)
  ]);

  // Calculate AI acceptance rate
  const aiTotal = aiGeneratedFlashcards - this.countFlashcards(userId, {
    source: 'ai_generated',
    status: 'pending_review'
  });
  const aiAcceptanceRate = aiTotal > 0 ? aiApproved / aiTotal : 0;

  return {
    total_flashcards: totalFlashcards,
    active_flashcards: activeFlashcards,
    pending_review_flashcards: pendingReviewFlashcards,
    rejected_flashcards: rejectedFlashcards,
    manual_flashcards: manualFlashcards,
    ai_generated_flashcards: aiGeneratedFlashcards,
    ai_acceptance_rate: Math.round(aiAcceptanceRate * 100) / 100,
    flashcards_due_today: flashcardsDueToday,
    total_generation_requests: totalGenerationRequests,
    total_reviews_completed: 0 // Placeholder - requires review history tracking
  };
}

private async countFlashcards(
  userId: string,
  filters?: { status?: string; source?: string }
): Promise<number> {
  let query = this.supabase
    .from('flashcards')
    .select('*', { count: 'exact', head: true })
    .eq('user_id', userId);

  if (filters?.status) query = query.eq('status', filters.status);
  if (filters?.source) query = query.eq('source', filters.source);

  const { count } = await query;
  return count || 0;
}

private async countDueFlashcards(userId: string): Promise<number> {
  const now = new Date().toISOString();
  const { count } = await this.supabase
    .from('flashcards')
    .select('*', { count: 'exact', head: true })
    .eq('user_id', userId)
    .eq('status', 'active')
    .lte('next_review_at', now);

  return count || 0;
}

private async countGenerationRequests(userId: string): Promise<number> {
  const { count } = await this.supabase
    .from('generation_requests')
    .select('*', { count: 'exact', head: true })
    .eq('user_id', userId);

  return count || 0;
}
```

### Route Handler

```typescript
export async function GET(context: APIContext) {
  const user = context.locals.user;

  if (!user) {
    return errorResponse(401, "AUTH_REQUIRED", "Authentication required");
  }

  const service = new StatisticsService(context.locals.supabase);
  const statistics = await service.getOverview(user.id);

  return new Response(JSON.stringify({ statistics }), {
    status: 200,
    headers: {
      "Content-Type": "application/json",
      "Cache-Control": "private, max-age=300", // Cache 5 minutes
    },
  });
}
```

## 5. Metrics Explained

- **total_flashcards:** All flashcards (any status)
- **active_flashcards:** Ready for study
- **pending_review_flashcards:** Awaiting approval from AI
- **rejected_flashcards:** Rejected AI flashcards
- **manual_flashcards:** Created manually
- **ai_generated_flashcards:** Generated by AI
- **ai_acceptance_rate:** (approved AI / total AI) excluding pending
- **flashcards_due_today:** Active flashcards with next_review_at <= now
- **total_generation_requests:** All generation requests
- **total_reviews_completed:** Placeholder (needs review history)

## 6. Performance

- Parallel queries for speed
- Caching (5 min) recommended
- Consider materialized view for large datasets

**Status:** Ready for Implementation
